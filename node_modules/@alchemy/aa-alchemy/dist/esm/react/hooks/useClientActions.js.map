{"version":3,"file":"useClientActions.js","sourceRoot":"","sources":["../../../../src/react/hooks/useClientActions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AACpD,OAAO,EAAE,WAAW,EAAE,MAAM,OAAO,CAAC;AAGpC,OAAO,EAAE,wBAAwB,EAAE,MAAM,cAAc,CAAC;AAqGxD,MAAM,UAAU,gBAAgB,CAO9B,IAAyD;IAEzD,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC;IAEjC,MAAM,EACJ,MAAM,EACN,SAAS,EAAE,iBAAiB,EAC5B,KAAK,EACL,WAAW,EACX,IAAI,GACL,GAAG,WAAW,CAIb;QACA,UAAU,EAAE,KAAK,EAA0D,EACzE,YAAY,EACZ,IAAI,GAC4C,EAAE,EAAE;YACpD,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,MAAM,IAAI,wBAAwB,CAAC,kBAAkB,CAAC,CAAC;YACzD,CAAC;YAED,MAAM,QAAQ,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;YACjC,OAAO,QAAQ,CAAC,YAAY,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;QACzC,CAAC;KACF,CAAC,CAAC;IAEH,MAAM,aAAa,GAAG,WAAW,CAC/B,CACE,MAAuD,EACvD,EAAE;QACF,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;QACtC,OAAO,MAAM,CAAC,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;IACxC,CAAC,EACD,CAAC,MAAM,CAAC,CACT,CAAC;IAEF,MAAM,kBAAkB,GAAG,WAAW,CACpC,KAAK,EACH,MAAuD,EACvD,EAAE;QACF,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,GAAG,MAAM,CAAC;QACtC,OAAO,WAAW,CAAC,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7C,CAAC,EACD,CAAC,WAAW,CAAC,CACd,CAAC;IAEF,OAAO;QACL,aAAa;QACb,kBAAkB;QAClB,IAAI;QACJ,iBAAiB;QACjB,KAAK;KACN,CAAC;AACJ,CAAC","sourcesContent":["import { useMutation } from \"@tanstack/react-query\";\nimport { useCallback } from \"react\";\nimport type { Chain, Client, Transport } from \"viem\";\nimport type { SupportedAccounts } from \"../../config\";\nimport { ClientUndefinedHookError } from \"../errors.js\";\nimport type { UseSmartAccountClientResult } from \"./useSmartAccountClient\";\n\nexport type UseClientActionsProps<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  }\n> = {\n  client?: UseSmartAccountClientResult<\n    TTransport,\n    TChain,\n    SupportedAccounts\n  >[\"client\"];\n  actions: (client: Client<TTransport, TChain, SupportedAccounts>) => TActions;\n};\n\nexport type UseClientActionsResult<\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  }\n> = {\n  executeAction: <TFunctionName extends ExecutableFunctionName<TActions>>(\n    params: ClientActionParameters<TActions, TFunctionName>\n  ) => void;\n  executeActionAsync: <TFunctionName extends ExecutableFunctionName<TActions>>(\n    params: ClientActionParameters<TActions, TFunctionName>\n  ) => Promise<ExecuteableFunctionResult<TFunctionName>>;\n  data: ReturnType<TActions[keyof TActions]> | undefined;\n  isExecutingAction: boolean;\n  error?: Error | null;\n};\n\nexport type ExecutableFunctionName<\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  }\n> = keyof TActions extends infer functionName extends string\n  ? [functionName] extends [never]\n    ? string\n    : functionName\n  : string;\n\nexport type ExecuteableFunctionResult<\n  TFunctionName extends ExecutableFunctionName<TActions>,\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  }\n> = ReturnType<TActions[TFunctionName]>;\n\nexport type ExecutableFunctionArgs<\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  },\n  TFunctionName extends ExecutableFunctionName<TActions> = ExecutableFunctionName<TActions>\n> = Parameters<TActions[TFunctionName]>;\n\n// All of this is based one how viem's `encodeFunctionData` works\nexport type ClientActionParameters<\n  TActions extends { [x: string]: (...args: any[]) => unknown } = {\n    [x: string]: (...args: any[]) => unknown;\n  },\n  TFunctionName extends ExecutableFunctionName<TActions> = ExecutableFunctionName<TActions>,\n  allArgs = ExecutableFunctionArgs<\n    TActions,\n    TFunctionName extends ExecutableFunctionName<TActions>\n      ? TFunctionName\n      : ExecutableFunctionName<TActions>\n  >\n> = {\n  functionName: TFunctionName;\n  args: allArgs;\n};\n\n/**\n * A hook that allows you to leverage client decorators to execute actions\n * and await them in your UX. This is particularly useful for using Plugins\n * with Modular Accounts.\n *\n * @example\n * ```tsx\n * const Foo = () => {\n *  const { client } = useSmartAccountClient({ type: \"MultiOwnerModularAccount\" });\n *  const { executeAction } = useClientActions({\n *    client,\n *    pluginActions: sessionKeyPluginActions,\n *  });\n *\n *  executeAction({\n *    functionName: \"isAccountSessionKey\",\n *    args: [{ key: \"0x0\" }],\n *  });\n * };\n * ```\n *\n * @param args the hooks arguments highlighted below\n * @param args.client the smart account client returned from {@link useSmartAccountClient}\n * @param args.actions the smart account client decorator you want to execute actions from\n * @returns an object containing methods to execute the actions as well loading and error states (see: {@link UseClientActionsResult})\n */\nexport function useClientActions<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TActions extends { [x: string]: (...args: any[]) => any } = {\n    [x: string]: (...args: any[]) => any;\n  }\n>(\n  args: UseClientActionsProps<TTransport, TChain, TActions>\n): UseClientActionsResult<TActions> {\n  const { client, actions } = args;\n\n  const {\n    mutate,\n    isPending: isExecutingAction,\n    error,\n    mutateAsync,\n    data,\n  } = useMutation<\n    ReturnType<TActions[keyof TActions]>,\n    Error,\n    ClientActionParameters<TActions, ExecutableFunctionName<TActions>>\n  >({\n    mutationFn: async <TFunctionName extends ExecutableFunctionName<TActions>>({\n      functionName,\n      args,\n    }: ClientActionParameters<TActions, TFunctionName>) => {\n      if (!client) {\n        throw new ClientUndefinedHookError(\"useClientActions\");\n      }\n\n      const actions_ = actions(client);\n      return actions_[functionName](...args);\n    },\n  });\n\n  const executeAction = useCallback(\n    <TFunctionName extends ExecutableFunctionName<TActions>>(\n      params: ClientActionParameters<TActions, TFunctionName>\n    ) => {\n      const { functionName, args } = params;\n      return mutate({ functionName, args });\n    },\n    [mutate]\n  );\n\n  const executeActionAsync = useCallback(\n    async <TFunctionName extends ExecutableFunctionName<TActions>>(\n      params: ClientActionParameters<TActions, TFunctionName>\n    ) => {\n      const { functionName, args } = params;\n      return mutateAsync({ functionName, args });\n    },\n    [mutateAsync]\n  );\n\n  return {\n    executeAction,\n    executeActionAsync,\n    data,\n    isExecutingAction,\n    error,\n  };\n}\n"]}