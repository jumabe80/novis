import { asyncPipe, } from "@alchemy/aa-core";
import {} from "@wagmi/cli";
import dedent from "dedent";
import { createPublicClient, getContract, http } from "viem";
import { IPluginAbi } from "../src/msca/abis/IPlugin.js";
import { ContractAbiGenPhase } from "./phases/contract-abi-gen.js";
import { ContractAddressesGenPhase } from "./phases/contract-addresses-gen.js";
import { ExecutionAbiGenPhase } from "./phases/execution-abi-gen.js";
import { PluginActionsGenPhase } from "./phases/plugin-actions/index.js";
import { PluginGeneratorPhase } from "./phases/plugin-generator/index.js";
const phases = [
    ContractAddressesGenPhase,
    PluginGeneratorPhase,
    PluginActionsGenPhase,
    ExecutionAbiGenPhase,
    ContractAbiGenPhase,
];
export function plugingen({ chain, connectionConfig, config, }) {
    return {
        name: "ERC6900PluginGen: This file is auto-generated by plugingen",
        run: async ({ contracts }) => {
            const imports = new Map();
            const addImport = (moduleName, member) => {
                if (!imports.has(moduleName)) {
                    imports.set(moduleName, {
                        types: new Set(),
                        members: new Set(),
                    });
                }
                const module = imports.get(moduleName);
                if (member.isType) {
                    module.types.add(member.name);
                }
                else {
                    module.members.add(member.name);
                }
            };
            const content = [];
            const types = new Map();
            const addType = (typeName, typeDef, isPublic) => {
                if (types.has(typeName)) {
                    throw new Error(`Type ${typeName} already exists`);
                }
                types.set(typeName, {
                    definition: typeDef.replace(";", ""),
                    isPublic: isPublic ?? false,
                });
            };
            if (contracts.length !== 1) {
                throw new Error("plugingen should be used with only one Contract per plugin invocation");
            }
            const rpcUrl = connectionConfig.rpcUrl == null
                ? `${chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? process.env.API_KEY}`
                : connectionConfig.rpcUrl;
            const client = createPublicClient({
                chain,
                transport: http(rpcUrl, {
                    fetchOptions: {
                        headers: {
                            Authorization: `Bearer ${connectionConfig.jwt}`,
                        },
                    },
                }),
            });
            const contract = contracts[0];
            contract.content = "";
            if (contract.address == null) {
                throw new Error("contract must have at least one address");
            }
            const address = typeof contract.address === "string"
                ? { [chain.id]: contract.address }
                : contract.address;
            if (!(chain.id in address)) {
                throw new Error(`contract address missing for the reference chain ${chain.id}`);
            }
            const plugin = getContract({
                address: address[chain.id],
                abi: IPluginAbi,
                client,
            });
            const result = await asyncPipe(...phases)({
                addImport,
                addType,
                content,
                config,
                contract,
                plugin,
            });
            const finalContent = dedent `
        ${Array.from(types.entries())
                .map(([name, type]) => `${type.isPublic ? "export" : ""} type ${name} = ${type.definition};`)
                .join("\n\n")}

        ${result.content.join("\n\n")}
      `;
            const finalImports = Array.from(imports.entries())
                .map(([moduleName, { members, types }]) => {
                return dedent `
            import { ${Array.from(members.values()).join(",")} ${members.size > 0 ? "," : ""} ${Array.from(types.values())
                    .map((x) => `type ${x}`)
                    .join(",")} } from "${moduleName}";
        `;
            })
                .join("\n");
            return {
                imports: finalImports,
                content: finalContent,
            };
        },
    };
}
//# sourceMappingURL=index.js.map