"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.plugingen = void 0;
const aa_core_1 = require("@alchemy/aa-core");
const dedent_1 = __importDefault(require("dedent"));
const viem_1 = require("viem");
const IPlugin_js_1 = require("../src/msca/abis/IPlugin.js");
const contract_abi_gen_js_1 = require("./phases/contract-abi-gen.js");
const contract_addresses_gen_js_1 = require("./phases/contract-addresses-gen.js");
const execution_abi_gen_js_1 = require("./phases/execution-abi-gen.js");
const index_js_1 = require("./phases/plugin-actions/index.js");
const index_js_2 = require("./phases/plugin-generator/index.js");
const phases = [
    contract_addresses_gen_js_1.ContractAddressesGenPhase,
    index_js_2.PluginGeneratorPhase,
    index_js_1.PluginActionsGenPhase,
    execution_abi_gen_js_1.ExecutionAbiGenPhase,
    contract_abi_gen_js_1.ContractAbiGenPhase,
];
function plugingen({ chain, connectionConfig, config, }) {
    return {
        name: "ERC6900PluginGen: This file is auto-generated by plugingen",
        run: async ({ contracts }) => {
            const imports = new Map();
            const addImport = (moduleName, member) => {
                if (!imports.has(moduleName)) {
                    imports.set(moduleName, {
                        types: new Set(),
                        members: new Set(),
                    });
                }
                const module = imports.get(moduleName);
                if (member.isType) {
                    module.types.add(member.name);
                }
                else {
                    module.members.add(member.name);
                }
            };
            const content = [];
            const types = new Map();
            const addType = (typeName, typeDef, isPublic) => {
                if (types.has(typeName)) {
                    throw new Error(`Type ${typeName} already exists`);
                }
                types.set(typeName, {
                    definition: typeDef.replace(";", ""),
                    isPublic: isPublic ?? false,
                });
            };
            if (contracts.length !== 1) {
                throw new Error("plugingen should be used with only one Contract per plugin invocation");
            }
            const rpcUrl = connectionConfig.rpcUrl == null
                ? `${chain.rpcUrls.alchemy.http[0]}/${connectionConfig.apiKey ?? process.env.API_KEY}`
                : connectionConfig.rpcUrl;
            const client = (0, viem_1.createPublicClient)({
                chain,
                transport: (0, viem_1.http)(rpcUrl, {
                    fetchOptions: {
                        headers: {
                            Authorization: `Bearer ${connectionConfig.jwt}`,
                        },
                    },
                }),
            });
            const contract = contracts[0];
            contract.content = "";
            if (contract.address == null) {
                throw new Error("contract must have at least one address");
            }
            const address = typeof contract.address === "string"
                ? { [chain.id]: contract.address }
                : contract.address;
            if (!(chain.id in address)) {
                throw new Error(`contract address missing for the reference chain ${chain.id}`);
            }
            const plugin = (0, viem_1.getContract)({
                address: address[chain.id],
                abi: IPlugin_js_1.IPluginAbi,
                client,
            });
            const result = await (0, aa_core_1.asyncPipe)(...phases)({
                addImport,
                addType,
                content,
                config,
                contract,
                plugin,
            });
            const finalContent = (0, dedent_1.default) `
        ${Array.from(types.entries())
                .map(([name, type]) => `${type.isPublic ? "export" : ""} type ${name} = ${type.definition};`)
                .join("\n\n")}

        ${result.content.join("\n\n")}
      `;
            const finalImports = Array.from(imports.entries())
                .map(([moduleName, { members, types }]) => {
                return (0, dedent_1.default) `
            import { ${Array.from(members.values()).join(",")} ${members.size > 0 ? "," : ""} ${Array.from(types.values())
                    .map((x) => `type ${x}`)
                    .join(",")} } from "${moduleName}";
        `;
            })
                .join("\n");
            return {
                imports: finalImports,
                content: finalContent,
            };
        },
    };
}
exports.plugingen = plugingen;
//# sourceMappingURL=index.js.map